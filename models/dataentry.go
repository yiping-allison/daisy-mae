package models

import (
	"errors"
	"strings"

	"github.com/jinzhu/gorm"
)

const (
	// ErrNotFound is returned when a record isn't found in the Entry database
	ErrNotFound = "models: entry not found"
)

// Entry represents a database entry of either an insect or
// fish in the postgres database
type Entry struct {
	Name        string `gorm:"not null"`
	SellPrice   int    `gorm:"column:sell_price"`
	NorthSt     string `gorm:"type:varchar(255);column:north_start"`
	NorthEnd    string `gorm:"type:varchar(255);column:north_end"`
	NorthMonths string `gorm:"type:varchar(255);column:north_hemi_months"`
	SouthSt     string `gorm:"type:varchar(255);column:south_start"`
	SouthEnd    string `gorm:"type:varchar(255);column:south_end"`
	SouthMonths string `gorm:"type:varchar(255);column:south_hemi_months"`
	Time        string `gorm:"type:varchar(255);column:time_of_day"`
	Location    string `gorm:"type:varchar(255);column:location"`
	Image       string `gorm:"type:varchar(255);column:image"`
	Type        string `gorm:"type:varchar(255);column:type"`
}

// EntryService handles interactions with the bug and fish (Entry) database
type EntryService interface {
	EntryDB
}

// EntryDB is used to interact with data entry database
//
// If the entry is found, we will return the entry and nil error
//
// If the entry is not found, we will return ErrNotFound
//
// Lastly, we will return any other errors not generated by
// this package
type EntryDB interface {
	ByName(name, tableName string) (*Entry, error)
	ByMonth(colName, month, entryType string) []Entry
	FindLike(name, tableName string) []Entry
}

type entryGorm struct {
	db *gorm.DB
}

type entryService struct {
	EntryDB
}

// Internal check if we're correctly implementing interface
var _ EntryDB = &entryGorm{}

// NewEntryService creates a new service to data entry database
func NewEntryService(db *gorm.DB) EntryService {
	return &entryService{
		EntryDB: &entryGorm{
			db: db,
		},
	}
}

// ByName looks up an entry by its name and returns the entry
// if it exists.
//
// If not, we will return an error
func (eg *entryGorm) ByName(name, tableName string) (*Entry, error) {
	var entry Entry
	db := eg.db.Table(tableName).Where("name = ?", name)
	err := first(db, &entry)
	if err != nil {
		return nil, err
	}
	return &entry, nil
}

// ByMonth will look up entries from the bug and fish database by hemisphere,
// month, and entry type (either bug or fish)
//
// It will return all entries which match the criterion.
//
// This function will not handle empty slices, so make sure to check for it
// in calling func
func (eg *entryGorm) ByMonth(colName, month, entryType string) []Entry {
	var entries []Entry
	mon := strings.Title(month[:3])
	eg.db.Table("bug_and_fish").Where(colName+" LIKE ? AND type = ?", "%"+mon+"%", entryType).Find(&entries)
	return entries
}

// FindLike will return all entries that are similar to the 'name' variable
// passed in
//
// It will return a slice of type Entry. This does not handle empty slices, so make
// sure to check for slice length in calling func
func (eg *entryGorm) FindLike(name, tableName string) []Entry {
	var entries []Entry
	eg.db.Table(tableName).Limit(6).Where("name LIKE ?", "%"+name+"%").Find(&entries)
	return entries
}

// first will query using the provided gorm.DB and it will
// get the first item returned and place it into dst. If nothing
// is found in the query, it will return ErrNotFound
func first(db *gorm.DB, dst interface{}) error {
	err := db.First(dst).Error
	if err == gorm.ErrRecordNotFound {
		return errors.New(ErrNotFound)
	}
	return err
}
